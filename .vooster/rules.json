{
  "rules": [
    {
      "type": "prd",
      "content": "# 자산 대시보드 PRD\n\n## 1. 제품 개요\n가계 재무 담당자가 월별 수입·지출·저축·통장 현황을 직관적으로 확인하고, 가족과 재무 요약을 투명하게 공유할 수 있는 웹 기반 대시보드 MVP.\n\n## 2. 문제 정의\n- 월별 지출 총합 및 주요 지표를 한눈에 보기 어려워 예산 관리가 번거롭다.\n- 가족에게 재무 상황을 공유하려면 엑셀·캡처·메신저 등을 번거롭게 사용해야 한다.\n\n## 3. 목표\n- 핵심 지표를 요약 카드·차트로 시각화해 5초 이내에 재무 상태를 파악한다.\n- 읽기 전용 링크 한 번으로 가족에게 대시보드를 공유한다.\n\n## 4. 핵심 지표(KPI)\n1. 월간 활성 사용자(MAU) ≥ 500\n2. 대시보드 공유 링크 생성률 ≥ 60%\n3. 월별 데이터 입력 완료율 ≥ 70%\n4. 사용자 만족도(NPS) ≥ 40\n\n## 5. 주요 기능\n| 우선순위 | 기능 | 설명 |\n|---|---|---|\n| P0 | 대시보드 홈 | 월급, 지출, 저축, 통장 잔액을 카드로 요약 표시 |\n| P0 | 월별 수입/지출 비교 차트 | Bar 또는 area chart 로 월별 수입·지출 변화를 시각화 |\n| P0 | 누적 저축 추이 라인차트 | 장기 저축액 변화를 꺾은선 그래프로 표시 |\n| P0 | 통장/계좌별 잔액 리스트 + 그래프 | 계좌명, 잔액, 파이차트 비율 표시 |\n| P0 | 월별 요약 리포트 다운로드 | PDF/CSV 로 월간 리포트 생성, 다운로드 |\n| P1 | 읽기 전용 공유 링크 | JWT 토큰 포함 URL 생성, 로그인 없이 열람 가능 |\n| P1 | 데이터 수동 입력 폼 | 월급, 지출, 저축, 계좌잔액 등을 테이블/모달에서 입력 |\n\n## 6. 비기능 요구사항\n- 반응형 웹(모바일 ≥ 375px, 데스크톱 ≥ 1440px)\n- 첫 화면 로딩 ≤ 2초, 인터랙션 응답 ≤ 200ms\n- 기본 다크 모드 지원 X (범위 제외)\n- 개인정보 미보관(계좌번호 등 없음), 입력 데이터는 암호화 저장\n\n## 7. 사용자 흐름\n1. 로그인 없이 ‘가계부 만들기’ → 계정 생성(이메일+PW) → 대시보드 초기화\n2. ‘데이터 입력’ 버튼 → 월별 금액 입력 → 저장\n3. 대시보드에 카드·차트 즉시 갱신\n4. ‘공유’ 클릭 → 읽기 전용 URL 복사 → 가족에게 전달\n5. 가족은 링크 열어 대시보드 열람(읽기 전용)\n\n## 8. 기술 스택\n- Next.js 15, TypeScript, TailwindCSS, shadcn/ui, lucide-react\n- 상태관리: @tanstack/react-query\n- 데이터베이스: Supabase Postgres\n- 인증: Supabase Auth (이메일)\n\n## 9. 로드맵(MVP 기준)\nWeek 1: 기획 확정, 디자인 시스템 설정\nWeek 2: DB 스키마 설계, 인증, 기본 레이아웃\nWeek 3: 데이터 입력 CRUD, 대시보드 카드 표시\nWeek 4: 차트 구현(수입/지출, 저축 추이, 계좌 파이차트)\nWeek 5: PDF/CSV 내보내기, 공유 링크 기능\nWeek 6: QA, 퍼포먼스 최적화, 배포(vercel)\n\n## 10. 리스크 및 해결\n- 수동 입력 번거로움 → 이후 API 연동 기능 로드맵에 포함\n- 데이터 프라이버시 → 최소 정보 저장, https, 서버측 암호화\n\n## 11. 성공 정의\nMVP 출시 3개월 내, 월 500명의 가족 재무 담당자가 매달 데이터를 입력하고 공유 링크를 생성한다.",
      "writedAt": "2025-08-28T15:06:02.469Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: Next.js 기반 웹 애플리케이션으로, 사용자(주로 가계 재무 담당자)가 월별 수입, 지출, 저축, 통장 현황을 시각적으로 확인하고, 가족과 재무 요약을 공유할 수 있도록 설계한다. MVP는 데이터 수동 입력을 지원하며, 읽기 전용 공유 링크를 제공한다.\n- **Core Technology Stack**: Next.js 15, TypeScript, TailwindCSS, shadcn/ui, lucide-react, @tanstack/react-query, Supabase (Postgres, Auth), date-fns, localforage\n- **Key Technical Objectives**:\n    - 빠른 초기 로딩 속도 (≤ 2초) 및 인터랙션 응답 속도 (≤ 200ms) 유지\n    - 반응형 디자인 지원 (모바일, 데스크톱)\n    - 데이터 암호화 저장 및 개인정보 보호\n    - 높은 대시보드 공유 링크 생성률 및 데이터 입력 완료율 달성\n- **Critical Technical Assumptions**:\n    - 사용자는 웹 환경에 익숙하며, 기본적인 데이터 입력 방법을 이해한다.\n    - MVP는 데이터 수동 입력을 기반으로 한다.\n    - Supabase의 안정적인 서비스 제공을 가정한다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 프레임워크          | Next.js 15                  | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 지원, 빠른 초기 로딩 속도, SEO 최적화 |\n| 언어              | TypeScript                  | 정적 타입 검사, 코드 안정성 및 유지보수성 향상 |\n| 스타일링          | TailwindCSS                 | 유틸리티 우선 CSS, 빠른 스타일링 및 일관성 유지 |\n| UI 컴포넌트       | shadcn/ui                   | 재사용 가능한 UI 컴포넌트, 디자인 시스템 통합 용이 |\n| 아이콘            | lucide-react                | 고품질 아이콘 제공, UI 완성도 향상 |\n| 상태 관리          | @tanstack/react-query       | 서버 상태 관리, 데이터 페칭 및 캐싱 효율성 향상 |\n| 데이터베이스       | Supabase Postgres           | 확장 가능한 관계형 데이터베이스, 안정적인 데이터 저장 |\n| 인증              | Supabase Auth               | 간편한 이메일 인증, 보안 강화 |\n| 날짜 처리          | date-fns                    | 날짜 및 시간 관련 작업 효율성 향상 |\n| 로컬 스토리지      | localforage               | 간단한 데이터 캐싱 및 사용자 경험 개선 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js)**\n    - UI 컴포넌트: shadcn/ui, lucide-react를 사용하여 사용자 인터페이스를 구성한다.\n    - 상태 관리: @tanstack/react-query를 통해 서버 상태를 효율적으로 관리한다.\n    - 라우팅: Next.js 내장 라우팅 시스템을 활용하여 페이지 이동을 처리한다.\n- **Backend (Supabase)**\n    - 데이터베이스: Supabase Postgres를 사용하여 사용자 데이터 및 대시보드 데이터를 저장한다.\n    - 인증: Supabase Auth를 통해 사용자 인증 및 권한 관리를 처리한다.\n    - API: Next.js API routes를 사용하여 프론트엔드와 데이터베이스 간의 통신을 처리한다.\n- **Shared Components**\n    - 유틸리티 함수: date-fns를 사용하여 날짜 관련 로직을 처리한다.\n    - 타입 정의: TypeScript를 사용하여 데이터 타입 및 인터페이스를 정의한다.\n    - 로컬 스토리지: localforage를 사용하여 간단한 데이터를 캐싱한다.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    B --> C[Supabase Postgres]\n    A --> D[Supabase Auth]\n```\n\n- **Frontend (Next.js) <-> Backend (Supabase)**: Next.js 애플리케이션은 API routes를 통해 Supabase 백엔드와 통신한다.\n- **Backend (Supabase) -> Supabase Postgres**: Supabase 백엔드는 Supabase Postgres 데이터베이스에 데이터를 저장하고 검색한다.\n- **Frontend (Next.js) -> Supabase Auth**: Next.js 애플리케이션은 Supabase Auth를 사용하여 사용자 인증을 처리한다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 대시보드 관리, 공유 기능 등으로 도메인을 분리한다.\n- **Layer-Based Architecture**: 프레젠테이션 레이어(UI 컴포넌트), 비즈니스 로직 레이어(hooks, utils), 데이터 접근 레이어(Supabase API)로 분리한다.\n- **Feature-Based Modules**: 각 기능별 폴더를 생성하여 관련 컴포넌트, 훅, 유틸리티 함수를 함께 관리한다.\n- **Shared Components**: 공통으로 사용되는 유틸리티 함수, 타입 정의, UI 컴포넌트는 `components/shared` 폴더에 저장한다.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/\n│   ├── dashboard/          # 대시보드 관련 컴포넌트\n│   │   ├── DashboardCard.tsx\n│   │   ├── IncomeExpenseChart.tsx\n│   │   └── ...\n│   ├── shared/             # 공통 컴포넌트\n│   │   ├── Button.tsx\n│   │   ├── Input.tsx\n│   │   └── ...\n│   └── ui/                 # shadcn/ui 컴포넌트 오버라이딩\n│       ├── button.tsx\n│       ├── input.tsx\n│       └── ...\n├── pages/\n│   ├── api/                # Next.js API routes\n│   │   ├── dashboard.ts\n│   │   ├── share.ts\n│   │   └── ...\n│   ├── dashboard.tsx       # 대시보드 페이지\n│   ├── index.tsx           # 랜딩 페이지\n│   └── login.tsx           # 로그인 페이지\n├── utils/\n│   ├── date-utils.ts       # 날짜 관련 유틸리티 함수\n│   ├── api-client.ts       # Supabase API 클라이언트\n│   └── ...\n├── types/\n│   ├── dashboard.ts        # 대시보드 관련 타입 정의\n│   ├── user.ts             # 사용자 관련 타입 정의\n│   └── ...\n├── public/               # 정적 파일\n│   ├── favicon.ico\n│   └── ...\n├── styles/               # 전역 스타일\n│   ├── globals.css\n│   └── ...\n├── next.config.js        # Next.js 설정 파일\n├── tsconfig.json         # TypeScript 설정 파일\n└── package.json          # 프로젝트 의존성\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 프론트엔드는 Next.js API routes를 통해 백엔드와 통신하며, API 요청/응답 패턴을 사용한다.\n- **Database Interaction**: Supabase API 클라이언트를 사용하여 Supabase Postgres 데이터베이스에 데이터를 저장하고 검색한다. ORM은 사용하지 않는다.\n- **External Service Integration**: Supabase Auth를 사용하여 사용자 인증을 처리한다.\n- **Data Synchronization**: @tanstack/react-query를 사용하여 서버 상태를 관리하고, 데이터 변경 시 자동으로 UI를 업데이트한다.\n\n## 4. Performance & Optimization Strategy\n- Next.js의 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 기능을 활용하여 초기 로딩 속도를 최적화한다.\n- 이미지 최적화 및 코드 스플리팅을 통해 번들 크기를 줄인다.\n- @tanstack/react-query의 캐싱 기능을 활용하여 불필요한 API 요청을 줄인다.\n- 데이터베이스 쿼리 최적화를 통해 데이터 접근 속도를 향상시킨다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 프로젝트 설정, 기본 레이아웃 구성\n- **Essential Features**: 사용자 인증 (Supabase Auth), 데이터 입력 폼, 대시보드 카드 표시\n- **Basic Security**: HTTPS 적용, 데이터 암호화 저장\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축 (Vercel)\n- **Timeline**: Week 1-2\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 월별 수입/지출 비교 차트, 누적 저축 추이 라인차트, 통장/계좌별 잔액 리스트 + 그래프, 월별 요약 리포트 다운로드, 읽기 전용 공유 링크\n- **Performance Optimization**: 코드 최적화, 데이터베이스 쿼리 최적화, 이미지 최적화\n- **Enhanced Security**: 추가적인 보안 검토 및 취약점 수정\n- **Monitoring Implementation**: 오류 로깅 및 성능 모니터링 시스템 구축\n- **Timeline**: Week 3-5\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Next.js, Supabase 등 사용 기술에 대한 숙련도 부족 → 팀 내 학습 및 외부 자료 활용\n- **Performance Risks**: 데이터 증가에 따른 성능 저하 → 데이터베이스 쿼리 최적화, 캐싱 전략 적용\n- **Security Risks**: 데이터 유출 및 보안 취약점 → 데이터 암호화, 정기적인 보안 검토\n- **Integration Risks**: Supabase 서비스 장애 → Supabase 상태 모니터링, 대체 서비스 검토\n- **Mitigation Strategies**:\n    - 기술 스택에 대한 충분한 학습 및 경험 축적\n    - 성능 테스트 및 프로파일링을 통한 병목 지점 파악 및 개선\n    - 정기적인 보안 검토 및 취약점 점검\n    - Supabase 서비스 상태 모니터링 및 장애 발생 시 대응 계획 수립\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연 → 스프린트 계획 및 데드라인 준수, 우선순위 조정\n- **Resource Risks**: 개발 인력 부족 → 추가 인력 투입 또는 기능 축소\n- **Quality Risks**: 코드 품질 저하 → 코드 리뷰 및 테스트 자동화\n- **Deployment Risks**: 배포 과정에서의 문제 발생 → 배포 자동화 및 롤백 전략 수립\n- **Contingency Plans**:\n    - 개발 일정 지연 시 기능 우선순위 조정 및 개발 범위 축소\n    - 개발 인력 부족 시 추가 인력 투입 또는 외부 전문가 활용\n    - 코드 품질 저하 시 코드 리뷰 강화 및 테스트 자동화 시스템 구축\n    - 배포 과정 문제 발생 시 롤백 및 문제 해결 후 재배포\n",
      "writedAt": "2025-08-28T15:06:02.469Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-08-28T15:06:02.469Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-28T15:06:02.469Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-28T15:06:02.469Z"
    }
  ]
}